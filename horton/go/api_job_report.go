/*
 * Horton
 * John Shields
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"fmt"
	"github.com/GIT_USER_ID/GIT_REPO_ID/go/config"
	"github.com/GIT_USER_ID/GIT_REPO_ID/go/models"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"log"
	"net/http"
)

// CreateReport - Create a report
func CreateReport(c *gin.Context) {
	var report models.JobReport

	// Blind data to object, else throw error
	if err := c.BindJSON(&report); err != nil {
		fmt.Println(err.Error())
	}

	// Report details
	if err := InsertJobReport(report); err == nil {
	} else {
		log.Printf("\n[INFO] Not completing request")
	}
	// Customer Details
	if err := InsertCustomer(report); err == nil {
	} else {
		log.Printf("\n[INFO] Not completing request")
	}
}

// TODO - Connect to logged in worker
func InsertJobReport(report models.JobReport) error {
	db := config.DbConn()

	//checkForCookie(c)

	fmt.Println("\n[INFO] Processing Job Report Details...",
		"\nReport Number:", report.JobReportId, "\nReport Date:", report.Date)

	insert, err := db.Prepare("INSERT INTO jobreports(worker_id, date_stamp, vehicle_model, vehicle_reg, vehicle_location, " +
		"miles_on_vehicle, warranty, breakdown, cause, correction, parts, work_hours, job_report_complete) " +
		"VALUES (141, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")

	if err != nil {
		log.Println("\n[INFO] MySQL Error: Error Creating new Report:\n", err)
	}

	result, err := insert.Exec(report.Date, report.VehicleModel, report.VehicleReg, report.VehicleLocation,
		report.MilesOnVehicle, report.Warranty, report.Breakdown, report.Cause, report.Correction, report.Parts,
		report.WorkHours, report.JobComplete)

	log.Println(report.JobReportId)

	if err != nil {
		log.Println("\n[INFO] MySQL Error: Creating new Report:\n", err)
	}
	fmt.Println("\n[INFO] Print MySQL Results for Report:\n", result)

	defer db.Close()
	// Everything is good
	return nil
}

// TODO - Get job_report_id from InsertJobReport
func InsertCustomer(report models.JobReport) error {
	db := config.DbConn()

	fmt.Println("\n[INFO] Processing Customer Details...",
		"\nCustomer Name:", report.CustomerName)

	insert, err := db.Prepare("INSERT INTO customers (job_report_id, customer_name, customer_complaint)" +
		" VALUES (661, ?, ?)")

	if err != nil {
		log.Println("\n[INFO] MySQL Error: Error Creating new Report:\n", err)
	}

	result, err := insert.Exec(report.JobReportId, report.CustomerName, report.Complaint)

	if err != nil {
		log.Println("\n[INFO] MySQL Error: Creating new Report:\n", err)
	}

	fmt.Println("\n[INFO] Print MySQL Results for Report:\n", result)

	defer db.Close()
	// Everything is good
	return nil
}

// DeleteReport - Delete a Job Report == Working
func DeleteReport(c *gin.Context) {
	db := config.DbConn()
	// Get id from request
	jobReportId := c.Params.ByName("jobReportId")
	//Create query
	res, err := db.Exec("DELETE FROM jobreports WHERE job_report_id=?", jobReportId)

	if err != nil {
		// return user friendly message to client
		fmt.Printf("500 Internal Server Error.")
		c.JSON(500, nil)
	}

	affectedRows, err := res.RowsAffected()

	if err != nil {
		// return user friendly message to client
		fmt.Printf("500 Internal Server Error.")
		c.JSON(500, nil)
	}

	fmt.Printf("The statement affected %d rows\n", affectedRows)

	c.JSON(http.StatusOK, gin.H{})
}

// GetReportById - Get a job report
// TODO - Do more then just ID, have it check by date, and customer name
func GetReportById(c *gin.Context) {

	//checkForCookie(c)

	db := config.DbConn()
	// Get id from request
	jobReportId := c.Params.ByName("jobReportId")
	// Testing Log message
	log.Printf(string(jobReportId))
	//Create query
	selDB, err := db.Query("SELECT DISTINCT jr.job_report_id, jr.date_stamp, jr.vehicle_model,"+
		"jr.vehicle_reg, jr.miles_on_vehicle, jr.vehicle_location, jr.warranty, jr.breakdown, "+
		"cust.customer_name, cust.customer_complaint, jr.cause, jr.correction, jr.parts, jr.work_hours,"+
		"wkr.worker_name, jr.job_report_complete FROM jobreports jr INNER JOIN customers cust"+
		"ON jr.job_report_id = cust.job_report_id"+
		"INNER JOIN workers wkr ON jr.worker_id = wkr.worker_id", jobReportId) // job_report_id

	fmt.Println("\n[INFO] Processing Reports...")

	if err != nil {
		// return user friendly message to client
		fmt.Printf("500 Internal Server Error.")
		c.JSON(500, nil)
	}

	var report models.JobReport

	// Check each record for a match on jobReportId
	if selDB.Next() {
		err = selDB.Scan(&report.JobReportId, &report.Date, &report.VehicleModel,
			&report.VehicleReg, &report.VehicleLocation, &report.MilesOnVehicle, &report.Warranty, &report.Breakdown)

		if err != nil {
			// return user friendly message to client
			fmt.Printf("500 Internal Server Error.")
			c.JSON(500, nil)
		}
		//Print report that was found
		fmt.Printf("%v\n", report)
		c.JSON(http.StatusOK, report)
	} else {
		fmt.Printf("[INFO] No job matching the Id provided was found.")
		c.JSON(404, nil) // No report found, report 404 error and no null object
	}
	defer db.Close()
}

// TODO - Fix return object, should be the customer one as it has more fields then job report
// Make sure query is working right with auth
func GetReports(c *gin.Context) {

	//if !checkForCookie(c) {
	//	c.Redirect(302, "/api/v1/logout")
	//} else {
	db := config.DbConn()

	// Create query
	selDB, err := db.Query("SELECT DISTINCT jr.job_report_id, jr.date_stamp, jr.vehicle_model, " +
		"jr.vehicle_reg, jr.miles_on_vehicle, jr.vehicle_location, jr.warranty, jr.breakdown, " +
		"cust.customer_name, cust.customer_complaint, jr.cause, jr.correction, jr.parts, jr.work_hours, " +
		"wkr.worker_name, jr.job_report_complete " +
		"FROM jobreports jr INNER JOIN customers cust " +
		"ON jr.job_report_id = cust.job_report_id " +
		"INNER JOIN workers wkr ON jr.worker_id = wkr.worker_id WHERE wkr.worker_id = 141") // worker_id

	fmt.Println("\n[INFO] Processing Reports...")

	if err != nil {
		// return user friendly message to client
		log.Println("\n[INFO] Failed to process reports!")
		fmt.Printf("500 Internal Server Error.")
		c.JSON(500, nil)
	}

	var res []models.JobReport
	fmt.Println("[INFO] Loading model...")

	// Run through each record and read values
	for selDB.Next() {
		var report models.JobReport

		err = selDB.Scan(&report.JobReportId, &report.Date, &report.VehicleModel, &report.VehicleReg, &report.MilesOnVehicle,
			&report.VehicleLocation, &report.Warranty, &report.Breakdown, &report.CustomerName, &report.Complaint, &report.Cause,
			&report.Correction, &report.Parts, &report.WorkHours, &report.WorkerName, &report.JobComplete)

		if err != nil {
			// return user friendly message to client
			log.Println("\n[INFO] Failed to load model!")
			fmt.Printf("\n500 Internal Server Error.")
			c.JSON(500, nil)
		}
		// Add each record to array
		res = append(res, report)
		log.Printf(string(report.JobReportId))
	}
	// Return values, Status OK
	c.JSON(http.StatusOK, res)

	fmt.Println("\n[INFO] Reports Processed.", res)
	defer db.Close()
}

//} // if else - cookie

// UpdateReport - Update a job report
func UpdateReport(c *gin.Context) {
	// Read in values from client request and build object.
	// Added object to db table
	// Return 201 response for "Created"
	// Handle error responses in each error if statement
	c.JSON(http.StatusOK, gin.H{})
}
