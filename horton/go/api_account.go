/*
 * John Shields
 * Horton
 *
 * Account API
 * Handles Register & Login
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"fmt"
	"github.com/GIT_USER_ID/GIT_REPO_ID/go/config"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"log"
	"net/http"
	"strings"
)

var wa WorkerAccount

// Login - Log in
// TODO - implement auth
func Login(c *gin.Context) {
	// // Comparing the password with the hash
	//    err = bcrypt.CompareHashAndPassword(hashedPassword, password)
	//    fmt.Println(err) // nil means it is a match
	c.JSON(http.StatusOK, gin.H{})
}

// Register - Registers User
func Register(c *gin.Context) {
	var user InlineObject
	
	// Blind data to object, else throw error
	if err := c.BindJSON(&user); err != nil {
		fmt.Println(err.Error())
	}

	username := user.Username
	password := user.Password

	if err := registerNewUser(username, user.Name, password); err == nil {
		db := config.DbConn()

		// User has been created now set the following below
		token := generateSessionId() // Create a new session ID
		expiry := 3600

		// INSERT QUERY to create an Account
		insert, err := db.Prepare("INSERT INTO session(id, user, expire_after) VALUES(?, ?, ?)")

		if err != nil {
			fmt.Println(err.Error())
		}

		log.Println("Printing worker account details", wa)
		log.Println("Printing worker account details", token, " ", wa.Id, " ", expiry )

		// Check for worker account before committing session record
		if isValidAccount(username); err != nil{
			log.Println("Error doing worker account lookup in database")
		}

		if _, err = insert.Exec(token, wa.Id, expiry); err != nil{
			log.Println("MYSQL Error: Error creating new session record\n", err)
			defer db.Close()
			c.JSON(400, Error{Code: 400, Messages: "Malformed Request"})
		} else {
			log.Println("Session has been generated. Records: " + token, " ", wa.Id, " ", expiry)
			defer db.Close()
			c.JSON(http.StatusCreated, gin.H{})
		}
		defer db.Close()
	} else {
		log.Printf("Not completing request")
	}

}

// Function to create a session ID using UUID for an authenticated user.
// This session id will be needed to allow the user to make requests from the client to the server.
func generateSessionId() string {
	return uuid.New().String()
}

// Function that registers a new user to the database.
func registerNewUser(username, name, password string) error {
	db := config.DbConn()

	if strings.TrimSpace(password) == "" {
		log.Printf("password is null")
		return errors.New("password is null")
	} else if !isValidAccount(username) {
		log.Printf("username taken")
		return errors.New("username is already taken")
	}

	// Hash the password here
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

	if err != nil {
		log.Fatal("Hash Password failed: ", err)
	}

	insert, err := db.Prepare("INSERT INTO workers(username, worker_name, hash) VALUES (?, ?, ?)")

	if err != nil {
		log.Println("MySQL Error: Error Creating new user account:\n", err)
	}

	result, err := insert.Exec(username, name, hashedPassword)

	if err != nil{
		log.Println("MySQL Error: Error Creating new user account:\n", err)
	}

	log.Println("Print MySQL Results for user account:\n", result)

	defer db.Close()
	// Everything is good
	return nil
}

// Function to do a database look up and check if a username matches one provided.
func isValidAccount(username string) bool {
	db := config.DbConn()

	selDB, err := db.Query("SELECT * FROM workers WHERE username=?", username)

	if err != nil {
		log.Fatal(err)
	}

	if selDB.Next() {
		err = selDB.Scan(&wa.Id, &wa.Username, &wa.WorkerName, &wa.Password)

		log.Println(wa)

		if err != nil {
			// return false // No user matching username provided
			log.Println("MySQL Error:\n", err)
		}
		defer db.Close()
		// Username matches return false as its not valid
		return false
	} else {
		// Return false, username is valid as no user exist by it in the database.
		defer db.Close()
		return true
	}
}
