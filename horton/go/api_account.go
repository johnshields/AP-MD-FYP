/*
 * Horton
 * John Shields
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"fmt"
	"github.com/GIT_USER_ID/GIT_REPO_ID/go/config"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"log"
	"net/http"
	"strings"
)

var wa WorkerAccount

// Login - Log in
// TODO - implement auth
func Login(c *gin.Context) {
	// // Comparing the password with the hash
	//    err = bcrypt.CompareHashAndPassword(hashedPassword, password)
	//    fmt.Println(err) // nil means it is a match
	c.JSON(http.StatusOK, gin.H{})
}

// Register - Registers User
func Register(c *gin.Context) {
	var user InlineObject

	// current problem with binding
	err :=  c.ShouldBindJSON(&user)
	if err != nil {
		log.Println(user.Username)
		fmt.Println(err.Error())
	}
	log.Println(c.Params)

	username := user.Username
	password := user.Password

	if err := registerNewUser(username, user.Name, password); err == nil {
		db := config.DbConn()

		// User has been created now set the following below
		token := generateSessionId() // Create a new session ID
		expiry := 3600

		// INSERT QUERY to create an Account
		insert, err := db.Prepare("INSERT INTO session(id, user, expire_after) VALUES(?, ?, ?)")
		log.Println(token, wa.Id, expiry)

		if err != nil {
			fmt.Println(err.Error())
			panic(err.Error())
		}

		_, err = insert.Exec(token, wa.Id, expiry)
		log.Println(c.Params)
		log.Println("Session has been generated" + token, wa.Id, expiry)

		c.JSON(http.StatusCreated, gin.H{})
	} else {
		c.JSON(400, Error{Code: 400, Messages: "Malformed Request"})
	}
}

// Function to create a session ID using UUID for an authenticated user.
// This session id will be needed to allow the user to make requests from the client to the server.
func generateSessionId() string {
	return uuid.New().String()
}

// Function that registers a new user to the database.
func registerNewUser(username, name, password string) error {
	db := config.DbConn()

	if strings.TrimSpace(password) == "" {
		return errors.New("password is null")
	} else if !isValidAccount(username) {
		return errors.New("username is already taken")
	}

	// Hash the password here
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	log.Println(hashedPassword)

	if err != nil{
		log.Fatal(err)
	}

	insert, err := db.Prepare("INSERT INTO workers(worker_id, username, worker_name, hash) VALUES (?, ?, ?, ?)")
	log.Println(username, name)

	if err != nil{
		log.Fatal(err)
	}

	insert.Exec(username, name, hashedPassword)
	log.Println("Account has been created" + username + name)


	// Get command for inserting into workers table, id should auto increment
	// so you shouldn't need to set it
	// Log the account created

	// Everything is good
	return nil
}

// Function to do a database look up and check if a username matches one provided.
func isValidAccount(username string) bool {
	db := config.DbConn()

	selDB, err := db.Query("SELECT * FROM workers WHERE username=?", username)

	if err != nil {
		log.Fatal(err)
	}

	if selDB.Next() {
		err = selDB.Scan(&wa.Id, &wa.Username, &wa.WorkerName)

		if err != nil {
			//return false // No user matching username provided
			log.Fatal(err)
		}
		defer db.Close()
		// Username matches
		return true
	} else {
		// Return false, username is valid as no user exist by it in the database.
		defer db.Close()
		return false
	}
}
