/*
 * John Shields
 * Horton
 *
 * Account API
 * Handles Register & Login
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"errors"
	"fmt"
	"github.com/GIT_USER_ID/GIT_REPO_ID/go/config"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"log"
	"net/http"
	"strings"
)

var wa WorkerAccount

// Login - Log in
func Login(c *gin.Context) {
	db := config.DbConn()

	// have the user login in by username and password
	var workerForm WorkerAccount

	if err := c.BindJSON(&workerForm); err != nil {
		fmt.Println(err.Error())
	}

	username := workerForm.Username
	password := workerForm.Password

	result, err := db.Query("SELECT * FROM workers WHERE username=? AND hash=?", username, password)
	fmt.Println("\nEntered username\n", username, "\nEntered Password\n", password)

	if err != nil {
		log.Println("MySQL Error: Error finding user:\n", err)
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

	if err != nil {
		log.Fatal("Hash Password failed: ", err)
	}

	// Comparing the password with the hash
	err = bcrypt.CompareHashAndPassword(hashedPassword, []byte(password))
	fmt.Println(err) // nil means it is a match

	// check to see if the user details are correct
	err = loginUser(username, password)

	if err != nil {
		fmt.Println(err.Error())
	}

	log.Println(username)
	log.Println(password)
	log.Println(result)
	defer db.Close()
	c.JSON(http.StatusOK, gin.H{})
}

// Function that registers a new user to the database.
func loginUser(username, password string) error {

	if strings.TrimSpace(password) == "" {
		log.Printf("password is null")
		return errors.New("password is null")
	} else if !isValidAccount(password) {
		log.Printf("unknown password")
		return errors.New("password is wrong")
	}
	if isValidAccount(username) {
		log.Printf("unknown username")
		return errors.New("username does not exist")
	}
	// Everything is good
	log.Println("Print MySQL Results for logged in user:\n",username, password)
	return nil
}

// Register - Registers User
func Register(c *gin.Context) {
	var user InlineObject

	// Blind data to object, else throw error
	if err := c.BindJSON(&user); err != nil {
		fmt.Println(err.Error())
	}

	username := user.Username
	password := user.Password

	if err := registerNewUser(username, user.Name, password); err == nil {
		db := config.DbConn()

		// User has been created now set the following below
		token := generateSessionId() // Create a new session ID
		expiry := 3600 * 24 * 3      // 3600 * 24 * 3 = 3 days

		// INSERT QUERY to create an Account
		insert, err := db.Prepare("INSERT INTO session(id, user, expire_after) VALUES(?, ?, ?)")

		if err != nil {
			fmt.Println(err.Error())
		}

		fmt.Println("\n\nPrinting Worker Account details:", "\nSession Token:\n", token, "\nWorker ID:\n", wa.Id,
			"\nExpiry time in seconds:\n", expiry)

		// Check for worker account before committing session record
		if isValidAccount(username); err != nil {
			log.Println("Error doing worker account lookup in database")
		}

		if _, err = insert.Exec(token, wa.Id, expiry); err != nil {
			log.Println("MYSQL Error: Error creating new session record\n", err)
			defer db.Close()
			c.JSON(400, Error{Code: 400, Messages: "Malformed Request"})
		} else {
			fmt.Println("\n\nSession has been generated! \nRecords:", "\nSession Token:\n", token, "\nWorker ID:\n", wa.Id,
				"\nExpiry time in seconds:\n", expiry)
			fmt.Println("\nWorker Username:\n", username)

			defer db.Close()
			c.JSON(http.StatusCreated, gin.H{})
		}
		defer db.Close()
	} else {
		log.Printf("Not completing request")
	}

}

// Function to create a session ID using UUID for an authenticated user.
// This session id will be needed to allow the user to make requests from the client to the server.
func generateSessionId() string {
	return uuid.New().String()
}

// Function that registers a new user to the database.
func registerNewUser(username, name, password string) error {
	db := config.DbConn()

	if strings.TrimSpace(password) == "" {
		log.Printf("password is null")
		return errors.New("password is null")
	} else if !isValidAccount(username) {
		log.Printf("username taken")
		return errors.New("username is already taken")
	}

	// Hash the password here
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

	if err != nil {
		log.Fatal("Hash Password failed: ", err)
	}

	insert, err := db.Prepare("INSERT INTO workers(username, worker_name, hash) VALUES (?, ?, ?)")

	if err != nil {
		log.Println("MySQL Error: Error Creating new user account:\n", err)
	}

	result, err := insert.Exec(username, name, hashedPassword)

	if err != nil {
		log.Println("MySQL Error: Error Creating new user account:\n", err)
	}

	fmt.Println("Print MySQL Results for user account:\n", result)

	defer db.Close()
	// Everything is good
	return nil
}

// Function to do a database look up and check if a username matches one provided.
func isValidAccount(username string) bool {
	db := config.DbConn()

	selDB, err := db.Query("SELECT * FROM workers WHERE username=?", username)

	if err != nil {
		log.Fatal(err)
	}

	if selDB.Next() {
		err = selDB.Scan(&wa.Id, &wa.Username, &wa.WorkerName, &wa.Password)

		log.Println(wa)

		if err != nil {
			// return false // No user matching username provided
			log.Println("MySQL Error:\n", err)
		}
		defer db.Close()
		// Username matches return false as its not valid
		return false
	} else {
		// Return false, username is valid as no user exist by it in the database.
		defer db.Close()
		return true
	}
}